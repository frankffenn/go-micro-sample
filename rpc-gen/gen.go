package rpc_gen

import (
	"bytes"
	"fmt"
	"go/format"
	"golang.org/x/xerrors"
	"io"
	"os"
	"reflect"
	"strings"
	"text/template"
)

type Field struct {
	Name    string
	Pointer bool
	Type    reflect.Type
	Pkg     string

	IterLabel string
}

func typeName(pkg string, t reflect.Type) string {
	switch t.Kind() {
	case reflect.Array:
		return fmt.Sprintf("[%d]%s", t.Len(), typeName(pkg, t.Elem()))
	case reflect.Slice:
		return "[]" + typeName(pkg, t.Elem())
	case reflect.Ptr:
		return "*" + typeName(pkg, t.Elem())
	case reflect.Map:
		return "map[" + typeName(pkg, t.Key()) + "]" + typeName(pkg, t.Elem())
	default:
		pkgPath := t.PkgPath()
		if pkgPath == "" {
			// It's a built-in.
			return t.String()
		} else if pkgPath == pkg {
			return t.Name()
		}
		return fmt.Sprintf("%s.%s", resolvePkgName(pkgPath, t.String()), t.Name())
	}
}

func (f Field) TypeName() string {
	return typeName(f.Pkg, f.Type)
}

func (f Field) ElemName() string {
	return typeName(f.Pkg, f.Type.Elem())
}

func (f Field) IsArray() bool {
	return f.Type.Kind() == reflect.Array
}

func (f Field) Len() int {
	return f.Type.Len()
}

type Method struct {
	Service string
	Name string
	In reflect.Type
	Out reflect.Type
}

type GenTypeInfo struct {
	Name   string
	Fields []Field
	Methods []Method
}

func (gti *GenTypeInfo) Imports() []Import {
	var imports []Import
	for _, f := range gti.Fields {
		switch f.Type.Kind() {
		case reflect.Struct:
			if !f.Pointer{
				continue
			}
		case reflect.Bool:
			continue
		}
		imports = append(imports, ImportsForType(f.Pkg, f.Type)...)
	}

	for _, f := range gti.Methods {
		imports = append(imports, ImportsForType(f.In.PkgPath(), f.In)...)
		imports = append(imports, ImportsForType(f.Out.PkgPath(), f.Out)...)
	}
	return imports
}

func ParseTypeInfo(i interface{}) (*GenTypeInfo, error) {
	t := reflect.TypeOf(i)

	pkg := t.PkgPath()

	out := GenTypeInfo{
		Name: t.Name(),
	}

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		if !nameIsExported(f.Name) {
			continue
		}

		ft := f.Type
		var pointer bool
		if ft.Kind() == reflect.Ptr {
			ft = ft.Elem()
			pointer = true
		}

		out.Fields = append(out.Fields, Field{
			Name:    f.Name,
			Pointer: pointer,
			Type:    ft,
			Pkg:     pkg,
		})
	}

	pt := reflect.PtrTo(reflect.TypeOf(i))

	for i:= 0; i < pt.NumMethod(); i++ {
		m := pt.Method(pt.NumMethod() - i -1)
		if m.Type.NumIn() < 3{
			return nil, xerrors.New("unexpected number of input argument")
		}
		if m.Type.NumOut() != 1 {
			return nil,xerrors.New("unexpected number of output argument")
		}

		out.Methods = append(out.Methods, Method{
			Service:t.Name(),
			Name: m.Name,
			In: m.Type.In(2),
			Out:m.Type.In(3),
		})
	}

	return &out, nil
}

func nameIsExported(name string) bool {
	return strings.ToUpper(name[0:1]) == name[0:1]
}

func WriteServicesToFile(fname, pkg string, types ...interface{}) error {
	buf := new(bytes.Buffer)

	typeInfos := make([]*GenTypeInfo, len(types))
	for i, t := range types {
		gti, err := ParseTypeInfo(t)
		if err != nil {
			return xerrors.Errorf("failed to parse type info: %w", err)
		}
		typeInfos[i] = gti
	}

	if err := PrintHeaderAndUtilityMethods(buf, pkg, typeInfos); err != nil {
		return xerrors.Errorf("failed to write header: %w", err)
	}

	for _, t := range typeInfos {
		if err := GenServiceForType(t, buf); err != nil {
			return xerrors.Errorf("failed to generate service: %w", err)
		}
	}

	data, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	fi, err := os.Create(fname)
	if err != nil {
		return xerrors.Errorf("failed to open file: %w", err)
	}

	_, err = fi.Write(data)
	if err != nil {
		_ = fi.Close()
		return err
	}
	_ = fi.Close()

	return nil
}

func PrintHeaderAndUtilityMethods(w io.Writer, pkg string, typeInfos []*GenTypeInfo) error {
	var imports []Import
	for _, gti := range typeInfos {
		for _, i := range gti.Imports() {
			imports = append(imports, i)
		}
	}

	imports = append(imports, defaultImports...)
	imports = dedupImports(imports)

	data := struct {
		Package string
		Imports []Import
	}{pkg, imports}
	return doTemplate(w, data, `// Code generated by rpc-gen. DO NOT EDIT.

package {{ .Package }}

import (
	"fmt"
	"io"

{{ range .Imports }}{{ .Name }} "{{ .PkgPath }}"
{{ end }}
)

`)
}

func doTemplate(w io.Writer, info interface{}, templ string) error {
	t := template.Must(template.New("").Funcs(template.FuncMap{
		"Indirect": func(v reflect.Type) reflect.Type {
			if v.Kind() != reflect.Ptr {
				return v
			}
			return v.Elem()
		},
	}).Parse(templ))
	return t.Execute(w, info)
}


func GenServiceForType(gti *GenTypeInfo, w io.Writer) error {
	if err := emitServiceInstance(gti, w); err != nil {
		return err
	}

	if err := emitServiceMethods(gti.Methods, w); err != nil {
		return err
	}

	return nil
}

func emitServiceInstance(gti *GenTypeInfo, w io.Writer) error {
	err := doTemplate(w, gti, `

// Client API for {{ .Name }} service

type {{ .Name }}Service struct {
	c    client.Client
	name string
}

func New{{ .Name }}Service(name string, c client.Client) *{{ .Name }}Service {
	return &{{ .Name }}Service{
		c: c,
		name:name,
	}
}

func requestOpts() []client.RequestOption {
	return []client.RequestOption{
		client.WithContentType("application/json"),
	}
}
`)

	return err
}

func emitServiceMethods(methods []Method, w io.Writer) error {

	for i:= 0; i < len(methods); i++ {
		err := doTemplate(w, methods[i], `
func (c *{{ .Service }}Service) {{ .Name }}(ctx context.Context, in {{ .In }}, opts ...client.CallOption) ({{ .Out }}, error) {
	req := c.c.NewRequest(c.name, "{{ .Service}}.{{ .Name }}", in, requestOpts()...)
	out := new({{ Indirect .Out }})
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

`)
		if err != nil {
			return err
		}
	}
	return nil
}